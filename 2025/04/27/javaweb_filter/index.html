<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Javaweb_filter | Mr.Nie's Blogs</title><meta name="author" content="Mr.Nie"><meta name="copyright" content="Mr.Nie"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Session和Cookie什么是会话跟踪技术会话跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。保持对用户会话期间的数据管理。常用的会话跟踪技术是Cookie与Session。 Cookie通过在客户端记录信息确定用户身份 Session通过在服务器端记录信息确定用户身份。 Cookie1.什么是cookie12Cookie是客户端(一般指浏览器)请求服务器后,服务器发给客户端的一个辨认标">
<meta property="og:type" content="article">
<meta property="og:title" content="Javaweb_filter">
<meta property="og:url" content="https://nyx-1037.github.io/2025/04/27/javaweb_filter/index.html">
<meta property="og:site_name" content="Mr.Nie&#39;s Blogs">
<meta property="og:description" content="Session和Cookie什么是会话跟踪技术会话跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。保持对用户会话期间的数据管理。常用的会话跟踪技术是Cookie与Session。 Cookie通过在客户端记录信息确定用户身份 Session通过在服务器端记录信息确定用户身份。 Cookie1.什么是cookie12Cookie是客户端(一般指浏览器)请求服务器后,服务器发给客户端的一个辨认标">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nyx-1037.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-04-26T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-27T14:13:35.284Z">
<meta property="article:author" content="Mr.Nie">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nyx-1037.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Javaweb_filter",
  "url": "https://nyx-1037.github.io/2025/04/27/javaweb_filter/",
  "image": "https://nyx-1037.github.io/img/butterfly-icon.png",
  "datePublished": "2025-04-26T16:00:00.000Z",
  "dateModified": "2025-04-27T14:13:35.284Z",
  "author": [
    {
      "@type": "Person",
      "name": "Mr.Nie",
      "url": "https://nyx-1037.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://nyx-1037.github.io/2025/04/27/javaweb_filter/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Javaweb_filter',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Mr.Nie's Blogs</span></a><a class="nav-page-title" href="/"><span class="site-name">Javaweb_filter</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Javaweb_filter</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-26T16:00:00.000Z" title="发表于 2025-04-27 00:00:00">2025-04-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-27T14:13:35.284Z" title="更新于 2025-04-27 22:13:35">2025-04-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaWeb/">JavaWeb</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Session和Cookie"><a href="#Session和Cookie" class="headerlink" title="Session和Cookie"></a>Session和Cookie</h1><h2 id="什么是会话跟踪技术"><a href="#什么是会话跟踪技术" class="headerlink" title="什么是会话跟踪技术"></a>什么是会话跟踪技术</h2><p>会话跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。保持对用户会话期间的数据管理。常用的会话跟踪技术是Cookie与Session。</p>
<p>Cookie通过在客户端记录信息确定用户身份</p>
<p>Session通过在服务器端记录信息确定用户身份。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="1-什么是cookie"><a href="#1-什么是cookie" class="headerlink" title="1.什么是cookie"></a>1.什么是cookie</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie是客户端(一般指浏览器)请求服务器后,服务器发给客户端的一个辨认标识，保存在客户端，当客户端再次向服务器发送请求时，会携带着这个辨认标识，服务器就可以通过这个标识来识别客户端的身份或状态等。</span><br><span class="line">   Cookie的作用：跟踪会话，记录一次会话中(即Session，一次会话可能会有多次请求，当然也可以有多个Cookie来跟踪不同的信息)的信息，这样服务器就会知道用户的状态，比如有没有登录成功，付款时购物车中的东西等，就相当于贴在客户端脑门上的纸条，浏览器看不到，但服务器看得到。</span><br></pre></td></tr></table></figure>

<h3 id="2-Cookie的应用"><a href="#2-Cookie的应用" class="headerlink" title="2.Cookie的应用"></a>2.Cookie的应用</h3><p><strong>2.1 保持用户登录状态</strong></p>
<p>将用户的信息保存到Cookie中，并发送给浏览器，并且将有效时间设置为一个较长的时间，这样浏览器在以后访问网站时，都会带着该Cookie，服务器以此来辨识用户，用户就不再需要输入用户名和密码等信息。</p>
<p><strong>2.2  记录用户名</strong></p>
<p>​		一旦用户登录成功以后，下次再登录时，直接将Cookie中的用户名读取并显示出来，这样用户就不需要再次输入用户名，只输入密码即可。							</p>
<h3 id="3-Cookie的设置和获取"><a href="#3-Cookie的设置和获取" class="headerlink" title="3. Cookie的设置和获取"></a>3. Cookie的设置和获取</h3><p><strong>3.1 、通过HttpServletResponse.addCookie的方式设置Cookie</strong></p>
<p>​	注意:new Cookie()时两个参数都是字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;jieguo&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>

<p><strong>3.2、浏览器中查看cookie的内容</strong></p>
<p><img src="https://nyx-1037.github.io/2025/04/27/javaweb_filter/%E6%95%88%E6%9E%9C.png" alt="在这里插入图片描述"></p>
<p><strong>3.3、服务端获取客户端携带的cookie：通过HttpServletRequest获取</strong>    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%				</span><br><span class="line">				Cookie[] cookies = request.getCookies();</span><br><span class="line">					<span class="keyword">if</span>(cookies != <span class="literal">null</span>)</span><br><span class="line">						<span class="keyword">for</span>(Cookie c : cookies)&#123;</span><br><span class="line">							<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> c.getName();<span class="comment">//获取Cookie名称</span></span><br><span class="line">							<span class="keyword">if</span>(<span class="string">&quot;jieguo&quot;</span>.equals(name))&#123;</span><br><span class="line">								<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> c.getValue();<span class="comment">//获取Cookie的值</span></span><br><span class="line">								bool = Boolean.valueOf(value);<span class="comment">//将值转为Boolean类型</span></span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-删除Cookie"><a href="#4-删除Cookie" class="headerlink" title="4.删除Cookie"></a><strong>4.删除Cookie</strong></h3><p>通过设置同名Cookie的最大存活时间为0，删除Cookie是指使浏览器不再保存Cookie，使Cookie立即失效</p>
<p>举例：使name为username的Cookie立即失效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个name为username的Cookie</span></span><br><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="comment">//2.设置Cookie的有效时间为0</span></span><br><span class="line">cookie.setMaxAge(<span class="number">0</span>);<span class="comment">//删除cookie的关键</span></span><br><span class="line"><span class="comment">//3.将cookie发送给浏览器，来替换同名Cookie</span></span><br><span class="line">response.addCookie(cookie);           </span><br></pre></td></tr></table></figure>

<p><strong>Cookie的有效时间</strong></p>
<p> Cookie发送给浏览器以后，浏览器并不会永久保存，也就是到了一定的时间以后浏览器会自动销毁Cookie。Cookie的默认有效时间为一次会话(一次打开关闭浏览器的过程)，我们也可以手动指定Cookie的有效时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//setMaxAge用来设置Cookie的最大有效时间，需要int型的参数，代表有效的秒数</span></span><br><span class="line">cookie.setMaxAge(秒数)；</span><br><span class="line"><span class="comment">//当参数大于0时，会设置为指定的秒数</span></span><br><span class="line">cookie.setMaxAge(<span class="number">30</span>);</span><br><span class="line"><span class="comment">//当参数等于0时,浏览器不会保存Cookie,Cookie立即失效</span></span><br><span class="line">cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//当参数小于0时，和不设置是一样，当前会话有效</span></span><br><span class="line">cookie.setMaxAge(-<span class="number">100</span>);</span><br><span class="line"><span class="comment">//设置一个永久有效的Cookie，并非永久，只是使Cookie的生命很长而已</span></span><br><span class="line">cookie.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">365</span>*<span class="number">10</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h4 id="1-什么是Session"><a href="#1-什么是Session" class="headerlink" title="1.什么是Session"></a>1.什么是Session</h4><p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p>
<p>如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</p>
<h4 id="2-创建Session的格式"><a href="#2-创建Session的格式" class="headerlink" title="2.创建Session的格式"></a>2.创建Session的格式</h4><p>​		Session对应的类为javax.servlet.http.HttpSession类。每个来访者对应一个Session对象，所有该客户的状态信息都保存在这个Session对象里。<strong>Session对象是在客户端第一次请求服务器的时候创建的</strong>。</p>
<pre><code>		Session也是一种key-value的属性对，通过getAttribute(Stringkey)和setAttribute(String key，Objectvalue)方法读写客户状态信息。Servlet里通过request.getSession()方法获取该客户的 Session
</code></pre>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();    <span class="comment">// 获取Session对象</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;loginTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());   <span class="comment">// 设置Session中的属性</span></span><br><span class="line">out.println(<span class="string">&quot;登录时间为：&quot;</span> +(Date)session.getAttribute(<span class="string">&quot;loginTime&quot;</span>));   <span class="comment">// 获取Session属性</span></span><br></pre></td></tr></table></figure>

<h4 id="3-Session的生命周期"><a href="#3-Session的生命周期" class="headerlink" title="3.Session的生命周期"></a>3.Session的生命周期</h4><p>Session保存在服务器端。<strong>为了获得更高的存取速度，服务器一般把Session放在内存里。每个用户都会有一个独立的Session。如果Session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。因此，Session里的信息应该尽量精简。</strong></p>
<p>Session在用户第一次访问服务器的时候自动创建。需要注意只有访问JSP、Servlet等程序时才会创建Session，只访问HTML、IMAGE等静态资源并不会创建Session。如果尚未生成Session，也可以使request.getSession(true)强制生成Session。</p>
<p>Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。用户每访问服务器一次，无论是否读写Session，服务器都认为该用户的Session“活跃（active）”了一次。</p>
<p>由于会有越来越多的用户访问服务器，因此Session也会越来越多。<strong>为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。</strong></p>
<p>Session的超时时间为maxInactiveInterval属性，可以通过对应的getMaxInactiveInterval()获取，通过			setMaxInactiveInterval(longinterval)修改。</p>
<p>Session的超时时间也可以在web.xml中修改。另外，通过调用Session的invalidate()方法可以使Session失效。	</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;session-config&gt;   </span><br><span class="line">    &lt;session-timeout&gt;<span class="number">30</span>&lt;/session-timeout&gt; </span><br><span class="line">&lt;/session-config&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4-Session常用的方法"><a href="#4-Session常用的方法" class="headerlink" title="4.Session常用的方法"></a>4.Session常用的方法</h4><table>
<thead>
<tr>
<th>方 法 名</th>
<th>描  述</th>
</tr>
</thead>
<tbody><tr>
<td>void setAttribute(String attribute, Object value)</td>
<td>设置Session属性。value参数可以为任何Java Object。通常为Java Bean。value信息不宜过大</td>
</tr>
<tr>
<td>String getAttribute(String attribute)</td>
<td>返回Session属性</td>
</tr>
<tr>
<td>Enumeration getAttributeNames()</td>
<td>返回Session中存在的属性名</td>
</tr>
<tr>
<td>void removeAttribute(String attribute)</td>
<td>移除Session属性</td>
</tr>
<tr>
<td>String getId()</td>
<td>返回Session的ID。该ID由服务器自动创建，不会重复</td>
</tr>
<tr>
<td>long getCreationTime()</td>
<td>返回Session的创建日期。返回类型为long，常被转化为Date类型，例如：Date createTime &#x3D; new Date(session.get CreationTime())</td>
</tr>
<tr>
<td>long getLastAccessedTime()</td>
<td>返回Session的最后活跃时间。返回类型为long</td>
</tr>
<tr>
<td>int getMaxInactiveInterval()</td>
<td>返回Session的超时时间。单位为秒。超过该时间没有访问，服务器认为该Session失效</td>
</tr>
<tr>
<td>void setMaxInactiveInterval(int second)</td>
<td>设置Session的超时时间。单位为秒</td>
</tr>
<tr>
<td>boolean isNew()</td>
<td>返回该Session是否是新创建的</td>
</tr>
<tr>
<td>void invalidate()</td>
<td>使该Session失效</td>
</tr>
</tbody></table>
<h4 id="5-Session的应用场景"><a href="#5-Session的应用场景" class="headerlink" title="5.Session的应用场景"></a>5.Session的应用场景</h4><p>​		代码演示：1.登录  2.退出(创建Session和消除Session)</p>
<h4 id="6-Session和Cookie的区别"><a href="#6-Session和Cookie的区别" class="headerlink" title="6.Session和Cookie的区别"></a>6.Session和Cookie的区别</h4><p>(1) Cookie数据保存在客户端，Session数据保存在服务器端。</p>
<p>(2) Session是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID 为标识符来存取服务器端的Session存储空间。而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一SessionID提交到服务器端，来存取Session数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用Cookie，那么Session也会失效。</p>
<p>(3) Cookies是属于Session对象的一种。但有不同，Cookies不会占服务器资源，是存在客服端内存或者一个Cookie的文本文件中；而Session则会占用服务器资源。所以，尽量不要使用Session，而使用Cookies。但是我们一般认为Cookie是不可靠的，Cookies是保存在本机上的，但是其信息的完全可见性且易于本地编辑性，往往可以引起很多的安全问题Session是可靠地。但是目前很多著名的站点也都用Cookie。</p>
<h1 id="过滤器-Filter"><a href="#过滤器-Filter" class="headerlink" title="过滤器(Filter)"></a>过滤器(Filter)</h1><h2 id="1-什么是过滤器"><a href="#1-什么是过滤器" class="headerlink" title="1.什么是过滤器"></a>1.什么是过滤器</h2><p>​		过滤器实际上就是对web资源进行拦截，做一些处理后再交给下一个过滤器或servlet处理，通常都是用来拦截request进行处理的，也可以对返回的response进行拦截处理</p>
<h2 id="2-过滤器的语法格式"><a href="#2-过滤器的语法格式" class="headerlink" title="2.过滤器的语法格式"></a><img src="https://nyx-1037.github.io/2025/04/27/javaweb_filter/a1.png">2.过滤器的语法格式</h2><p>2.1.创建一个类实现Filter接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharSetFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>2.2.重写接口中的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123; <span class="comment">//销毁的方法&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">   					<span class="comment">//过滤方法 主要是对request和response进行一些处理，然后交给下一个过滤器或Servlet处理</span></span><br><span class="line">    				chain.doFilter(req, resp);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">					<span class="comment">/*初始化方法  接收一个FilterConfig类型的参数 该参数是对Filter的一些配置*/</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>2.3.在web.xml文件中配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line"> 				&lt;filter-name&gt;过滤器名称&lt;/filter-name&gt;</span><br><span class="line"> 				&lt;filter-class&gt;过滤器所在的路径&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line"> 				&lt;filter-name&gt;过滤器名称&lt;/filter-name&gt;</span><br><span class="line"> 				&lt;url-pattern&gt;需要过滤的资源&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>
<h2 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3.使用场景"></a>3.使用场景</h2><p>3.1.如何防止用户未登录就执行后续操作</p>
<p>​          String name&#x3D;(String)session.getAttribute(“key”);</p>
<p>​          if(name&#x3D;&#x3D;null){</p>
<p>​                   &#x2F;&#x2F;跳转到登录页面</p>
<p>​          }</p>
<p>3.2.设置编码方式–统一设置编码</p>
<p>3.3.加密解密(密码的加密和解密)</p>
<p>3.4.非法文字筛选</p>
<p>3.5.下载资源的限制				</p>
<p> 过滤器的特点:在servlet之前和之后都会被执行			</p>
<h1 id="监听器-Listener"><a href="#监听器-Listener" class="headerlink" title="监听器(Listener)"></a>监听器(Listener)</h1><h3 id="1-什么是监听器"><a href="#1-什么是监听器" class="headerlink" title="1.什么是监听器"></a>1.什么是监听器</h3><p>​		监听器就是监听某个域对象的的状态变化的组件<br>​		监听器的相关概念：<br>​				事件源：被监听的对象(三个域对象 request、session、servletContext)<br>​				监听器：监听事件源对象事件源对象的状态的变化都会触发监听器<br>​				注册监听器：将监听器与事件源进行绑定<br>​				响应行为：监听器监听到事件源的状态变化时所涉及的功能代码（程序员编写代码）</p>
<h3 id="2-监听器分类"><a href="#2-监听器分类" class="headerlink" title="2.监听器分类"></a>2.监听器分类</h3><p>​			第一维度按照被监听的对象划分：ServletRequest域、HttpSession域、ServletContext域<br>​			第二维度按照监听的内容分：监听域对象的创建与销毁的、监听域对象的属性变化的<img src="https://nyx-1037.github.io/2025/04/27/javaweb_filter/a2.png" alt="a2"></p>
<h3 id="3-监听三大域对象的创建与销毁的监听器"><a href="#3-监听三大域对象的创建与销毁的监听器" class="headerlink" title="3.监听三大域对象的创建与销毁的监听器"></a>3.监听三大域对象的创建与销毁的监听器</h3><p><strong>监听器的编写步骤（重点）：</strong></p>
<p>​							编写一个监听器类去实现监听器接口<br>​							覆盖监听器的方法<br>​							需要在web.xml中进行配置—注册									</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">      &lt;listener-class&gt;监听器所在的路径&lt;/listener-class&gt; 									&lt;/listener&gt;</span><br></pre></td></tr></table></figure>

<p>ServletContextListener					</p>
<p>​						监听ServletContext域的创建与销毁的监听器</p>
<p>Servlet域的生命周期</p>
<p>​							何时创建：服务器启动创建<br>​							何时销毁：服务器关闭销毁</p>
<p>ServletContextListener监听器的主要作用</p>
<p>​							初始化的工作：初始化对象、初始化数据（加载数据库驱动、连接池的初始化）<br>​							加载一些初始化的配置文件(spring的配置文件）<br>​							任务调度(定时器—Timer&#x2F;TimerTask）</p>
<p>HttpSessionListener					</p>
<p>​						监听Httpsession域的创建和销毁的监听器</p>
<p>HttpSession对象的生命周期</p>
<p>​							何时创建：第一次调用request.getSession时创建<br>​							何时销毁：服务器关闭销毁、session过期（默认30分钟，修改默认的30分钟是在Tomcat的web.xml，修改当前项目的过期时间是在自己项目的web.xml中）、手动销毁</p>
<p>HttpSessionListener监听器的主要作用：</p>
<p>​				由于每次访问网站都会默认创建session对象（jsp页面中page指令中的session属性默认为true，即被访问时创建session），可以用于计数网站访问过的人</p>
<p>ServletRequestListener				</p>
<p>​						监听ServletRequest域创建与销毁的监听器</p>
<p>ServletRequest的生命周期</p>
<pre><code>							创建：每一次请求都会创建request
</code></pre>
<p>​							 销毁：请求结束</p>
<p>​							用法同上，用处不是很大，此处省略。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://nyx-1037.github.io">Mr.Nie</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://nyx-1037.github.io/2025/04/27/javaweb_filter/">https://nyx-1037.github.io/2025/04/27/javaweb_filter/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://nyx-1037.github.io" target="_blank">Mr.Nie's Blogs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/04/27/javaweb_smartupload/" title="Javaweb_smartupload"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Javaweb_smartupload</div></div><div class="info-2"><div class="info-item-1">使用smartupload.jar实现文件上传1.将jar包添加到项目中:smartupload.jar  2.准备上传的页面 12345 &lt;form action=&quot;toUpload&quot; method=&quot;post&quot;  enctype=&quot;multipart/form-data&quot; &gt;	书名:&lt;input type=&quot;text&quot; name=&quot;bookName&quot;/&gt;&lt;br&gt; 	图片:&lt;input type=&quot;file&quot; name=&quot;自定义名称&quot;/&gt;&lt;br&gt;	&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt;   注:(1)form标签中要添加enctype属性 ​     ...</div></div></div></a><a class="pagination-related" href="/2025/04/27/javaweb_ajax/" title="Javaweb_ajax"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Javaweb_ajax</div></div><div class="info-2"><div class="info-item-1">一 Ajax技术与原理1.1 Ajax简介AJAX &#x3D; Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。 1.2 Ajax所包含的技术大家都知道ajax并非一种新的技术，而是几种原有技术的结合体。它由下列技术组合而成。  1.使用CSS和XHTML来表示。 2.使用DOM模型来交互和动态显示。 3.使用XMLHttpRequest来和服务器进行异步通信。 4.使用javascript来绑定和调用。  AJAX 的核心是 XMLHttpRequest 对象。 不同的浏览器创建 XMLHttpRequest 对象的方法是有差异的。 IE 浏览器使用 ActiveXObject，而其他的浏览器使用名为 XMLHttpRequest 的 JavaScript 内建对象 1.3...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/25/fuxi1/" title="蓝桥杯复习资料1"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-25</div><div class="info-item-2">蓝桥杯复习资料1</div></div><div class="info-2"><div class="info-item-1">以下是针对蓝桥杯Java组备赛的增强版工具类及代码模板，包含详细注释和扩展内容，整合自多个真题解析和备赛资料（[3] [11] [17] [21]）：  一、核心工具类模板1. 快速输入输出（必会技巧 [11] [21]）1234567891011121314151617181920212223242526272829import java.io.*;import java.util.StringTokenizer;public class FastIO &#123;    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    static StringTokenizer st;    static PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));    // 读取整数（比Scanner快5倍）    static int nextInt() throws...</div></div></div></a><a class="pagination-related" href="/2025/04/26/javaweb_Servlet/" title="javaweb_Servlet"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-26</div><div class="info-item-2">javaweb_Servlet</div></div><div class="info-2"><div class="info-item-1">1. 什么是Servlet (1) Servlet（Server Applet），全称Java Servlet。是用Java编写的服务器端程序，其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。 (2)  Servlet运行于支持Java的应用服务器中。从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。 (3) Servlet工作模式： ​		①  客户端发送请求至服务器 ​		②  服务器启动并调用Servlet，Servlet根据客户端请求生成响应内容并将其传给服务器 ​		③  服务器将响应返回客户端 2. Servlet API  3. 第一个Servlet(1)...</div></div></div></a><a class="pagination-related" href="/2025/04/26/javaweb_tomcat/" title="javaweb_tomcat"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-26</div><div class="info-item-2">javaweb_tomcat</div></div><div class="info-2"><div class="info-item-1">1. HTTP协议简介超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。 HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。  2.HTTP 请求&#x2F;响应的步骤2.1 客户端连接到Web服务器 一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。 例如:http://www.baidu.com。 2.2...</div></div></div></a><a class="pagination-related" href="/2025/04/25/lanqiaobei1/" title="蓝桥杯算法知识点总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-25</div><div class="info-item-2">蓝桥杯算法知识点总结</div></div><div class="info-2"><div class="info-item-1">字符串相关操作 一、字符串生成与分割 split(regex)按正则表达式分割字符串，支持限制分割次数   123String str = &quot;a,b,c&quot;;String[] arr1 = str.split(&quot;,&quot;); // [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]String[] arr2 = str.split(&quot;,&quot;, 2); // [&quot;a&quot;,&quot;b,c&quot;]  String.join(delimiter, elements) (Java 8+)用指定分隔符连接字符串集合   12List&lt;String&gt; list = Arrays.asList(&quot;Java&quot;, &quot;Python&quot;, &quot;C++&quot;);String joined = String.join(&quot; | &quot;, list); // &quot;Java | Python |...</div></div></div></a><a class="pagination-related" href="/2025/04/25/lanqiaobei2/" title="蓝桥杯Java大学C组知识点复习资料"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-25</div><div class="info-item-2">蓝桥杯Java大学C组知识点复习资料</div></div><div class="info-2"><div class="info-item-1">蓝桥杯Java大学C组知识点复习资料1. 枚举 [1-3]例题：找出1~n中的所有质数题目描述：输入整数n，输出所有小于等于n的质数。输入输出示例： 12输入：10输出：2 3 5 7 代码实现： 123456789101112131415public class PrimeNumbers &#123;    public static void main(String[] args) &#123;        int n = 10;        for (int i = 2; i &lt;= n; i++) &#123; // 从2开始枚举            boolean isPrime = true;            for (int j = 2; j * j &lt;= i; j++) &#123; // 只需检查到平方根                if (i % j == 0) &#123;                    isPrime = false;                    break;               ...</div></div></div></a><a class="pagination-related" href="/2025/04/27/javaweb_jsp/" title="Javaweb_jsp"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-27</div><div class="info-item-2">Javaweb_jsp</div></div><div class="info-2"><div class="info-item-1">1. 什么是JSP​	JSP全名为Java Server Pages，中文名叫java服务器页面，其根本是一个简化的Servlet设计，它 是由Sun Microsystems公司倡导、许多公司参与一起建立的一种动态网页技术标准。JSP技术有点类似ASP技术，它是在传统的网页HTML文件(*.htm,*.html)中插入Java程序段(Scriptlet)和JSP标记(tag)，从而形成JSP文件，后缀名为(*.jsp)。 用JSP开发的Web应用是跨平台的，既能在Linux下运行，也能在其他操作系统上运行。 ​     JSP将网页逻辑与网页设计的显示分离，支持可重用的基于组件的设计，使基于Web的应用程序的开发变得迅速和容易。 *.html  静态页面(包含固定的页面内容) *.jsp     动态页面(页面数据可以动态更新,支持嵌套java代码和html代码) 2....</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Mr.Nie</div><div class="author-info-description">Welcome to Mr.Nie's Blogs website</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/nyx-1037"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/nyx-1037" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:nyx1037678078@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Session%E5%92%8CCookie"><span class="toc-number">1.</span> <span class="toc-text">Session和Cookie</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA%E6%8A%80%E6%9C%AF"><span class="toc-number">1.1.</span> <span class="toc-text">什么是会话跟踪技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie"><span class="toc-number">1.2.</span> <span class="toc-text">Cookie</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFcookie"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.什么是cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Cookie%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.Cookie的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Cookie%E7%9A%84%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%8E%B7%E5%8F%96"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. Cookie的设置和获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%88%A0%E9%99%A4Cookie"><span class="toc-number">1.2.4.</span> <span class="toc-text">4.删除Cookie</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Session"><span class="toc-number">1.3.</span> <span class="toc-text">Session</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFSession"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">1.什么是Session</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BASession%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">2.创建Session的格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Session%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">3.Session的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Session%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.0.4.</span> <span class="toc-text">4.Session常用的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Session%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.0.5.</span> <span class="toc-text">5.Session的应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Session%E5%92%8CCookie%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.0.6.</span> <span class="toc-text">6.Session和Cookie的区别</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8-Filter"><span class="toc-number">2.</span> <span class="toc-text">过滤器(Filter)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">1.什么是过滤器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">2.过滤器的语法格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.3.</span> <span class="toc-text">3.使用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8-Listener"><span class="toc-number">3.</span> <span class="toc-text">监听器(Listener)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">3.0.1.</span> <span class="toc-text">1.什么是监听器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%9B%91%E5%90%AC%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-number">3.0.2.</span> <span class="toc-text">2.监听器分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%9B%91%E5%90%AC%E4%B8%89%E5%A4%A7%E5%9F%9F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%94%80%E6%AF%81%E7%9A%84%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">3.0.3.</span> <span class="toc-text">3.监听三大域对象的创建与销毁的监听器</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/27/javaweb_jsp/" title="Javaweb_jsp">Javaweb_jsp</a><time datetime="2025-04-26T16:00:00.000Z" title="发表于 2025-04-27 00:00:00">2025-04-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/27/Git/" title="Git">Git</a><time datetime="2025-04-26T16:00:00.000Z" title="发表于 2025-04-27 00:00:00">2025-04-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/27/javaweb_smartupload/" title="Javaweb_smartupload">Javaweb_smartupload</a><time datetime="2025-04-26T16:00:00.000Z" title="发表于 2025-04-27 00:00:00">2025-04-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/27/javaweb_filter/" title="Javaweb_filter">Javaweb_filter</a><time datetime="2025-04-26T16:00:00.000Z" title="发表于 2025-04-27 00:00:00">2025-04-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/27/javaweb_ajax/" title="Javaweb_ajax">Javaweb_ajax</a><time datetime="2025-04-26T16:00:00.000Z" title="发表于 2025-04-27 00:00:00">2025-04-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Mr.Nie</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>