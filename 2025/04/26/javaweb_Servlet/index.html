<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>javaweb_Servlet | Mr.Nie's Blogs</title><meta name="author" content="Mr.Nie"><meta name="copyright" content="Mr.Nie"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 什么是Servlet (1) Servlet（Server Applet），全称Java Servlet。是用Java编写的服务器端程序，其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。 (2)  Servlet运行于支持Ja">
<meta property="og:type" content="article">
<meta property="og:title" content="javaweb_Servlet">
<meta property="og:url" content="https://nyx-1037.github.io/2025/04/26/javaweb_Servlet/index.html">
<meta property="og:site_name" content="Mr.Nie&#39;s Blogs">
<meta property="og:description" content="1. 什么是Servlet (1) Servlet（Server Applet），全称Java Servlet。是用Java编写的服务器端程序，其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。 (2)  Servlet运行于支持Ja">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nyx-1037.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-04-25T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-26T03:57:03.810Z">
<meta property="article:author" content="Mr.Nie">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nyx-1037.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "javaweb_Servlet",
  "url": "https://nyx-1037.github.io/2025/04/26/javaweb_Servlet/",
  "image": "https://nyx-1037.github.io/img/butterfly-icon.png",
  "datePublished": "2025-04-25T16:00:00.000Z",
  "dateModified": "2025-04-26T03:57:03.810Z",
  "author": [
    {
      "@type": "Person",
      "name": "Mr.Nie",
      "url": "https://nyx-1037.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://nyx-1037.github.io/2025/04/26/javaweb_Servlet/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'javaweb_Servlet',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Mr.Nie's Blogs</span></a><a class="nav-page-title" href="/"><span class="site-name">javaweb_Servlet</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">javaweb_Servlet</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-25T16:00:00.000Z" title="发表于 2025-04-26 00:00:00">2025-04-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-26T03:57:03.810Z" title="更新于 2025-04-26 11:57:03">2025-04-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaWeb/">JavaWeb</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="1-什么是Servlet"><a href="#1-什么是Servlet" class="headerlink" title="1. 什么是Servlet"></a>1. 什么是Servlet</h1><p><img src="https://nyx-1037.github.io/2025/04/26/javaweb_Servlet/req.png" alt="image-20200612180856091"></p>
<p>(1) Servlet（Server Applet），全称Java Servlet。是用Java编写的服务器端程序，其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。</p>
<p>(2)  Servlet运行于支持Java的应用服务器中。从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。</p>
<p>(3) Servlet工作模式：</p>
<p>​		①  客户端发送请求至服务器</p>
<p>​		②  服务器启动并调用Servlet，Servlet根据客户端请求生成响应内容并将其传给服务器</p>
<p>​		③  服务器将响应返回客户端</p>
<h1 id="2-Servlet-API"><a href="#2-Servlet-API" class="headerlink" title="2. Servlet API"></a>2. Servlet API</h1><img src="https://nyx-1037.github.io/2025/04/26/javaweb_Servlet/servlet.png" alt="image-20200612181752435" style="zoom: 150%;">

<h1 id="3-第一个Servlet"><a href="#3-第一个Servlet" class="headerlink" title="3. 第一个Servlet"></a>3. 第一个Servlet</h1><p>(1) 创建一个类实现Servlet接口,重写方法。或继承HttpServlet亦可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">//初始化方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//处理get/post请求的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//销毁的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) 在web.xml文档中配置映射关系</p>
<p>XML中配置好这个Servlet的映射关系：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>自定义名称<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>处理请求的类的完整路径<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span><span class="comment">&lt;!-- mapping 表示映射 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>自定义名称<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>请求名<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>标签的执行顺序：</p>
<p> 请求过来以后-&gt;web.xml-&gt;servlet-mapping标签中的url-pattern标签中的内容和请求名</p>
<p> 进行匹配-&gt;匹配成功后找对应的servlet-mapping标签中的servlet-name-&gt;</p>
<p> 去servlet标签中找和上一个servlet-name相同的name值-&gt;去找servlet标签中</p>
<p>的servlet-class中处理类的完整路径</p>
<p>(3) 启动tomcat，在浏览器输入<br>···<br><a target="_blank" rel="noopener" href="http://localhost:8080/%E5%B7%A5%E7%A8%8B%E5%90%8D/%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E8%B7%AF%E5%BE%84">http://localhost:8080/工程名/访问服务器的路径</a><br>···</p>
<h1 id="4-Servlet工作原理"><a href="#4-Servlet工作原理" class="headerlink" title="4. Servlet工作原理"></a>4. Servlet工作原理</h1><p>(1) Servlet接口定义了<strong>Servlet与servlet容器</strong>之间的契约。这个契约是：Servlet容器将Servlet类载入内存，并产生Servlet实例和调用它具体的方法。但是要注意的是，<strong>在一个应用程序中，每种Servlet类型只能有一个实例</strong>。</p>
<p>(2)用户请求致使Servlet容器调用Servlet的Service（）方法，<strong>并传入一个ServletRequest对象和一个ServletResponse对象</strong>。<strong>ServletRequest对象和ServletResponse对象都是由Servlet容器（例如TomCat）封装好的，并不需要程序员去实现，程序员可以直接使用这两个对象。</strong></p>
<p>(3)ServletRequest中封装了当前的Http请求，因此，开发人员不必解析和操作原始的Http数据。ServletResponse表示当前用户的Http响应，程序员只需直接操作ServletResponse对象就能把响应轻松的发回给用户。</p>
<p>(4)对于每一个应用程序，<strong>Servlet容器还会创建一个ServletContext对象。这个对象中封装了上下文（应用程序）的环境详情。每个应用程序只有一个ServletContext。每个Servlet对象也都有一个封装Servlet配置的ServletConfig对象。</strong></p>
<h1 id="5-Servlet的生命周期"><a href="#5-Servlet的生命周期" class="headerlink" title="5. Servlet的生命周期"></a>5. Servlet的生命周期</h1><p> 当客户端首次发送第一次请求后，由容器(web服务器(tomcat))去解析请求, 根据请求找到对应的servlet,判断该类的对象是否存在，不存在则创建servlet实例，调取init()方法 进行初始化操作,初始化完成后调取service()方法,由service()判断客户端的请求方式，如果是get，则执行doGet(),如果是post则执行doPost().处理方法完成后,作出相应结果给客户端.单次请求处理完毕。</p>
<p>当用户发送第二次以后的请求时,会判断对象是否存在,但是不再执行init()，而直接执行service方法,调取doGet()&#x2F;doPost()方法。</p>
<p>当服务器关闭时调取destroy()方法进行销毁。</p>
<p>  四个过程:</p>
<p>​     (1)实例化  –先创建servlet实例</p>
<p>​     (2)初始化   –init()</p>
<p>​     (3)处理请求  —service()</p>
<p>​     (4)服务终止  –destory()</p>
<img src="https://nyx-1037.github.io/2025/04/26/javaweb_Servlet/生命周期.png" alt="image-20200612183153403" style="zoom:50%;">

<h1 id="6-请求"><a href="#6-请求" class="headerlink" title="6. 请求"></a>6. 请求</h1><p>HttpServletRequest表示Http环境中的Servlet请求。它扩展于javax.servlet.ServletRequest接口)</p>
<p>常用方法:</p>
<p> 1)String  getParameter(String name)	根据表单组件名称获取提交数据，返回值是String</p>
<p>​     注：服务器在接收数据时使用字符串统一接收</p>
<p> 2)String[ ] getParameterValues(String name)	获取表单组件对应多个值时的请求数据 </p>
<p> 3)void setCharacterEncoding(String charset)	指定每个请求的编码(针对post请求才起作用)</p>
<p> 4)RequestDispatcher getRequestDispatcher(String path)	–跳转页面</p>
<p>​           返回一个RequestDispatcher对象，该对象的forward( )方法用于转发请求</p>
<p>​       示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">&quot;../success.jsp&quot;</span>).forward(request,response);</span><br></pre></td></tr></table></figure>

<p>5)存值 request.setAttribute(“key”,value);</p>
<p>6)取值 request.getAttribute(“key”);&#x2F;&#x2F;取值后需要向下转型</p>
<p>​       示例: String a1&#x3D;(String)request.getAttribute(“uname”);</p>
<p><strong>补充1:客户端如何发送数据给服务器</strong></p>
<p>方式1:通过表单 get&#x2F;post提交</p>
<p> 方式2:通过a标签发送数据（get提交）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;请求名?key=value&amp;key=value&amp;key=value...&quot;</span>&gt;</span><br><span class="line">示例:</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/login?a=10&amp;name=abc&amp;pass=123&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>这里的key值&#x3D;表单元素的控件名，value值&#x3D;表单中控件的value属性值</p>
<p>注:第一个参数使用?拼接,之后的参数使用&amp;拼接，获取数据还是通过  String name&#x3D;request.getParameter(“name”);</p>
<p> 方式3:通过地址栏直接拼接-get请求</p>
<p> 方式4:js提交数据-get请求</p>
<p>​                 location.href&#x3D;”目标请求?key&#x3D;value&amp;key&#x3D;value”</p>
<p>​           注:方式2&#x2F;3都属于get提交方式,表单提交可以使用get、post提交方式</p>
<p>​     </p>
<p><strong>补充2：处理请求乱码的问题</strong></p>
<p>​         方式1：setCharacterEncoding(“UTF-8”);&#x2F;&#x2F;post提交时管用</p>
<p>​         方式2: String s&#x3D;new String(变量名.getBytes(“ISO-8859-1”),”UTF-8”);&#x2F;&#x2F;针对于get提交时中文乱码</p>
<p>​               示例: String s&#x3D;new String(request.getParameter(“key”).getBytes(“ISO-8859-1”),”GBK”);</p>
<p>​         方式3：修改tomcat中配置文件:&#x2F;&#x2F;使用于get提交</p>
<p>​                在Tomcat目录结构\conf\server.xml中设置字符集             </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Connector</span> port=<span class="string">&quot;8080&quot;</span> protocol=<span class="string">&quot;HTTP/1.1&quot;</span>                              		</span><br><span class="line"> 			connectionTimeout=<span class="string">&quot;20000&quot;</span></span><br><span class="line">			redirectPort=<span class="string">&quot;8443&quot;</span> <span class="title class_">URIEncoding</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p> 注意:tomcat8.0以后不需要手动设置这个属性了</p>
<p><strong>补充3:get和post的区别</strong></p>
<p>1、GET请求，请求的数据会附加在URL之后，以?分割URL和传输数据，多个参数用&amp;连接。URL的编码格式采用的是ASCII编码，而不是uniclde，即是说所有的非ASCII字符都要编码之后再传输。</p>
<p>POST请求：POST请求会把请求的数据放置在HTTP请求包的包体中。上面的item&#x3D;bandsaw就是实际的传输数据。</p>
<p>因此，GET请求的数据会暴露在地址栏中，而POST请求则不会。</p>
<p>2、传输数据的大小</p>
<p>在HTTP规范中，没有对URL的长度和传输的数据大小进行限制。但是在实际开发过程中，对于GET，特定的浏览器和服务器对URL的长度有限制。因此，在使用GET请求时，传输数据会受到URL长度的限制。</p>
<p>对于POST，由于不是URL传值，理论上是不会受限制的，但是实际上各个服务器会规定对POST提交数据大小进行限制，Apache、IIS都有各自的配置。</p>
<p>3、安全性</p>
<p>POST的安全性比GET的高。这里的安全是指真正的安全，而不同于上面GET提到的安全方法中的安全，上面提到的安全仅仅是不修改服务器的数据。比如，在进行登录操作，通过GET请求，用户名和密码都会暴露再URL上，因为登录页面有可能被浏览器缓存以及其他人查看浏览器的历史记录的原因，此时的用户名和密码就很容易被他人拿到了。除此之外，GET请求提交的数据还可能会造成Cross-site request frogery攻击</p>
<h1 id="7-响应"><a href="#7-响应" class="headerlink" title="7. 响应"></a>7. 响应</h1><p>在Service API中，定义了一个HttpServletResponse接口，它继承自ServletResponse接口，专门用来封装HTTP响应消息。  在HttpServletResponse接口中定义了向客户端发送响应状态码，响应消息头，响应消息体的方法。</p>
<p> 常用方法:</p>
<p>void  addCookie(Cookie var1);&#x2F;&#x2F;给这个响应添加一个cookie</p>
<p>void sendRedirect(String var1) ;&#x2F;&#x2F;发送一条响应码，将浏览器跳转到指定的位置</p>
<p>PrintWriter  getWriter()   获得字符流，通过字符流的write(String s)方法可以将字符串设置到response  缓冲区中，随后Tomcat会将response缓冲区中的内容组装成Http响应返回给浏览器端。</p>
<p>setContentType()   设置响应内容的类型</p>
<p><img src="https://nyx-1037.github.io/2025/04/26/javaweb_Servlet/%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="img"></p>
<p>  <strong>重定向和转发的对比</strong></p>
<p>​      重定向:response.sendRedirect()</p>
<p>​      转发:request.getRequestDispatcher(“..&#x2F;success.jsp”).forward(request,response);</p>
<p>​      相同点:都用来跳转页面</p>
<p>​      不同点:</p>
<p>​          a.重定向时地址栏会改变,request中存储的数据会丢失.转发时地址栏显示的是请求页面的地址,request数据可以保存。</p>
<p>​          b.转发属于一次请求一次响应,重定向属于两次请求(地址栏修改了两次)两次响应。</p>
<p>​    补充:使用out对象往页面中输出js或html,css</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out.<span class="title function_">print</span>(<span class="string">&quot;&lt;script type=&#x27;text/javascript&#x27;&gt;alert(&#x27;登录失败&#x27;);location=&#x27;../login.jsp&#x27;&lt;/script&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​         注:使用js跳转页面，也会丢失request中的数据</p>
<h1 id="8-会话"><a href="#8-会话" class="headerlink" title="8. 会话"></a>8. 会话</h1><p>request存的值只能在单次请求中保存，保存的数据不能跨页面,当重定向时,request存的值会丢失</p>
<p>session的数据可以在多个页面中共享,即使重定向页面,数据不会丢失</p>
<p>session中可以包含n个request。</p>
<p>​     		会话的概念:从打开浏览器到关闭浏览器,期间访问服务器就称为一次会话</p>
<p>常用方法:</p>
<p>​    void     setAttribute(String key,Object value)	以key&#x2F;value的形式保存对象值,将数据存储在服务器端</p>
<p>​	Object getAttribute(String key)					  通过key获取对象值 </p>
<p>​	void invalidate()												设置session对象失效</p>
<p>​	String getId()													  获取sessionid,当第一次登录成功后，session会产生一个唯一的id，浏览器之后访问时如果发现id值还是之前id，那么说明 当前访问的属于同一个会话</p>
<p>   void setMaxInactiveInterval(int interval)   	设定session的非活动时间</p>
<p>​          示例: </p>
<p>​			方式1:   session.setMaxInactiveInterval(10*60);&#x2F;&#x2F;设置有效时间为10分钟</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方式2:修改web.xml    </span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>10<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span>//单位:分钟 </span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span>         </span><br></pre></td></tr></table></figure>

<p>​	int getMaxInactiveInterval()	          获取session的有效非活动时间(以秒为单位)，默认的有效时间:30分钟</p>
<p>​	void removeAttribute(String key)</p>
<p>​	 从session中删除指定名称(key)所对应的对象</p>
<p>​    小结 :让session失效的方式</p>
<p>​          （1）invalidate()  （2）removeAttribute(“key”)  （3）直接关闭浏览器。</p>
<p>​    示例:使用session验证用户是否登录</p>
<p>​    补充:</p>
<p>​	  自动刷新到某页面:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;3;url=index.jsp&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​       注:在head标签中添加该标签，单位:秒</p>
<h1 id="9-获得初始化参数"><a href="#9-获得初始化参数" class="headerlink" title="9.获得初始化参数"></a>9.获得初始化参数</h1><p> request.setCharacterEncoding(“utf-8”);代码的耦合度太高，不便于后期维护修改。可以通过初始化参数实现</p>
<p>实现方式:</p>
<p>  （1）web.xml中先定义初始化参数</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span><span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span><span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>(2)servlet中获得初始化参数，重写init()方法	</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">		  encoding= config.getInitParameter(<span class="string">&quot;encoding&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意:这种方式的初始化参数仅限于当前servlet中使用。</p>
<p>2.全局初始化参数</p>
<p> (1)定义，context-param是和servlet标签同级别</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>bianma<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>(2)获得数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  <span class="comment">// 请求-&gt;init()-&gt;service()-&gt;doget/dopost-&gt;destory();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">	bianhao=config.getServletContext().getInitParameter(<span class="string">&quot;bianma&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-servlet3-0"><a href="#10-servlet3-0" class="headerlink" title="10.servlet3.0"></a><strong>10.servlet3.0</strong></h1><p>注解(提供给程序读取的信息) –  注释(提供给程序员看的信息)</p>
<p>注解的格式：@开头的 如:@Override</p>
<p>@WebServlet注解配置Servlet</p>
<p>从Servlet3.0开始，配置Servlet支持注解方式，但还是保留了配置web.xml方式，所有使用Servlet有两种方式：</p>
<p>（1）Servlet类上使用@WebServlet注解进行配置</p>
<p>（2）web.xml文件中配置</p>
<p> @WebServlet常用属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>asyncSupported</td>
<td>boolean</td>
<td>否</td>
<td>指定Servlet是否支持异步操作模式</td>
</tr>
<tr>
<td>displayName</td>
<td>String</td>
<td>否</td>
<td>指定Servlet显示名称</td>
</tr>
<tr>
<td>initParams</td>
<td>webInitParam[]</td>
<td>否</td>
<td>配置初始化参数</td>
</tr>
<tr>
<td>loadOnStartup</td>
<td>int</td>
<td>否</td>
<td>标记容器是否在应用启动时就加载这个Servlet，等价于配置文件中的<load-on-startup>标签</load-on-startup></td>
</tr>
<tr>
<td>name</td>
<td>String</td>
<td>否</td>
<td>指定Servlet名称</td>
</tr>
<tr>
<td>urlPatterns&#x2F;value</td>
<td>String[]</td>
<td>否</td>
<td>这两个属性作用相同，指定Servlet处理的url</td>
</tr>
</tbody></table>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>a<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 处理类的完整路径 --&gt;</span></span><br><span class="line">       com.yhp.web.SelectServlet</span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试代码如下：</p>
<p>1.UserServlet</p>
<p>通过注解方式配置，web.xml中不需要配置该Servlet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(name = &quot;myUserServlet&quot;, </span></span><br><span class="line"><span class="meta">	urlPatterns = &quot;/user/test&quot;,   //斜杠必须</span></span><br><span class="line"><span class="meta">	loadOnStartup = 1,  </span></span><br><span class="line"><span class="meta">	initParams = &#123;</span></span><br><span class="line"><span class="meta">			@WebInitParam(name=&quot;name&quot;, value=&quot;小明&quot;), </span></span><br><span class="line"><span class="meta">			@WebInitParam(name=&quot;pwd&quot;, value=&quot;123456&quot;)</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7109220574468622594L</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">		<span class="built_in">super</span>.init(config);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;servlet初始化...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">		response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">		response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">		<span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">		</span><br><span class="line">		pw.append(<span class="string">&quot;Hello Servlet!&lt;br&gt;&quot;</span> );</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//servletName</span></span><br><span class="line">		pw.append(<span class="string">&quot;servletName：&quot;</span> + getServletName() + <span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//initParam</span></span><br><span class="line">		<span class="type">ServletConfig</span> <span class="variable">servletConfig</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletConfig();</span><br><span class="line">		Enumeration&lt;String&gt; paramNames = servletConfig.getInitParameterNames();</span><br><span class="line">		<span class="keyword">while</span> (paramNames.hasMoreElements()) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">paramName</span> <span class="operator">=</span> paramNames.nextElement();</span><br><span class="line">			pw.append(paramName + <span class="string">&quot;：&quot;</span> + servletConfig.getInitParameter(paramName) + <span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		pw.close();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">		doGet(request, response);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.测试结果</p>
<p>2.1应用启动时，servlet就会初始化，因为配置了loadOnStartup&#x3D;1</p>
<p><img src="https://nyx-1037.github.io/2025/04/26/javaweb_Servlet/rs1.png" alt="img"></p>
<p>2.2访问&#x2F;user&#x2F;test，页面上显示结果；表名参数正确初始化以及自定义的servlet名称</p>
<p><img src="https://nyx-1037.github.io/2025/04/26/javaweb_Servlet/rs2.png" alt="img"></p>
<p><strong>3.注</strong></p>
<p>(1).loadOnStartup属性：标记容器是否在启动应用时就加载Servlet，默认不配置或数值为负数时表示客户端第一次请求Servlet时再加载；0或正数表示启动应用就加载，正数情况下，数值越小，加载该Servlet的优先级越高；</p>
<p> <strong>实例：</strong>&#x2F;&#x2F;斜杠必须</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(value=&quot;/test1&quot;,loadOnStartup=1)</span></span><br></pre></td></tr></table></figure>

<p>(2).name属性：可以指定也可以不指定，通过getServletName()可以获取到，若不指定，则为Servlet的完整类名，如：cn.edu.njit.servlet.UserServlet</p>
<p>(3).urlPatterns&#x2F;value属性： String[]类型，可以配置多个映射，如：urlPatterns&#x3D;{“&#x2F;user&#x2F;test”, “&#x2F;user&#x2F;example”}</p>
<p>实例：</p>
<p>&#x2F;&#x2F;斜杠必须</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(loadOnStartup=1,urlPatterns= &#123;&quot;/test1&quot;,&quot;/test2&quot;&#125;)</span></span><br></pre></td></tr></table></figure>

<p>(4).在使用注解方式时，需要注意：</p>
<p><web-app> </web-app>根元素中不能配置属性metadata-complete&#x3D;”true”，否则无法加载Servlet。metadata-complete属性表示通知Web容器是否寻找注解，默认不写或者设置false，容器会扫描注解，为Web应用程序构建有效的元数据；metadata-complete&#x3D;”true”，会在启动时不扫描注解（annotation）。如果不扫描注解的话，用注解进行的配置就无法生效，例如：@WebServlet</p>
<p>(5).urlPatterns的常用规则：</p>
<p>​			&#x2F;*或者&#x2F;：拦截所有</p>
<p>​			*.do：拦截指定后缀</p>
<p>​			&#x2F;user&#x2F;test：拦截路径</p>
<p>​			&#x2F;user&#x2F;<em>.do、&#x2F;</em>.do、test*.do都是非法的，启动时候会报错</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://nyx-1037.github.io">Mr.Nie</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://nyx-1037.github.io/2025/04/26/javaweb_Servlet/">https://nyx-1037.github.io/2025/04/26/javaweb_Servlet/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://nyx-1037.github.io" target="_blank">Mr.Nie's Blogs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/04/25/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1$ hexo server  More info: Server Generate static files1$ hexo generate  More info: Generating Deploy to remote sites1$ hexo deploy  More info: Deployment </div></div></div></a><a class="pagination-related" href="/2025/04/26/javaweb_tomcat/" title="Javaweb_tomcat"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Javaweb_tomcat</div></div><div class="info-2"><div class="info-item-1">1. HTTP协议简介超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。 HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。  2.HTTP 请求&#x2F;响应的步骤2.1 客户端连接到Web服务器 一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。 例如:http://www.baidu.com。 2.2...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/25/fuxi1/" title="蓝桥杯复习资料1"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-25</div><div class="info-item-2">蓝桥杯复习资料1</div></div><div class="info-2"><div class="info-item-1">以下是针对蓝桥杯Java组备赛的增强版工具类及代码模板，包含详细注释和扩展内容，整合自多个真题解析和备赛资料（[3] [11] [17] [21]）：  一、核心工具类模板1. 快速输入输出（必会技巧 [11] [21]）1234567891011121314151617181920212223242526272829import java.io.*;import java.util.StringTokenizer;public class FastIO &#123;    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    static StringTokenizer st;    static PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));    // 读取整数（比Scanner快5倍）    static int nextInt() throws...</div></div></div></a><a class="pagination-related" href="/2025/04/27/Git/" title="Git"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-27</div><div class="info-item-2">Git</div></div><div class="info-2"><div class="info-item-1">1.版本控制如果在开发团队中没有使用版本控制，多个开发人员共同负责同一个软件或文档的开发，每个人在各自的机器上有整个软件文档的备份，并对之实施编程开发，在分别完成各自任务之后，再通过文本比对工具将各自机器上的不同版本的程序整合到一台机器上。没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事务性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。 版本控制的目的是实现开发团队并行开发、提高开发效率的基础。其目的在于对软件开发进程中文件或目录的发展过程提供有效的追踪手段，保证在需要时可回到旧的版本，避免文件的丢失、修改的丢失和相互覆盖，通过对版本库的访问控制避免未经授权的访问和修改，达到有效保护企业软件资产和知识产权的目的。 版本控制的功能在于跟踪记录整个软件的开发过程，包括软件本身和相关文档，以便对不同阶段的软件及相关文档进行表示并进行差别分析，对软件代码进行可撤消的修改，便于汇总不同开发人员所做的修改，辅助协调和管理软件开发团队。 2.版本控制工具2.1.Visual...</div></div></div></a><a class="pagination-related" href="/2025/04/27/javaweb_ajax/" title="Javaweb_ajax"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-27</div><div class="info-item-2">Javaweb_ajax</div></div><div class="info-2"><div class="info-item-1">一 Ajax技术与原理1.1 Ajax简介AJAX &#x3D; Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。 1.2 Ajax所包含的技术大家都知道ajax并非一种新的技术，而是几种原有技术的结合体。它由下列技术组合而成。  1.使用CSS和XHTML来表示。 2.使用DOM模型来交互和动态显示。 3.使用XMLHttpRequest来和服务器进行异步通信。 4.使用javascript来绑定和调用。  AJAX 的核心是 XMLHttpRequest 对象。 不同的浏览器创建 XMLHttpRequest 对象的方法是有差异的。 IE 浏览器使用 ActiveXObject，而其他的浏览器使用名为 XMLHttpRequest 的 JavaScript 内建对象 1.3...</div></div></div></a><a class="pagination-related" href="/2025/04/27/javaweb_jsp/" title="Javaweb_jsp"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-27</div><div class="info-item-2">Javaweb_jsp</div></div><div class="info-2"><div class="info-item-1">1. 什么是JSP​	JSP全名为Java Server Pages，中文名叫java服务器页面，其根本是一个简化的Servlet设计，它 是由Sun Microsystems公司倡导、许多公司参与一起建立的一种动态网页技术标准。JSP技术有点类似ASP技术，它是在传统的网页HTML文件(*.htm,*.html)中插入Java程序段(Scriptlet)和JSP标记(tag)，从而形成JSP文件，后缀名为(*.jsp)。 用JSP开发的Web应用是跨平台的，既能在Linux下运行，也能在其他操作系统上运行。 ​     JSP将网页逻辑与网页设计的显示分离，支持可重用的基于组件的设计，使基于Web的应用程序的开发变得迅速和容易。 *.html  静态页面(包含固定的页面内容) *.jsp     动态页面(页面数据可以动态更新,支持嵌套java代码和html代码) 2....</div></div></div></a><a class="pagination-related" href="/2025/04/27/javaweb_filter/" title="Javaweb_filter"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-27</div><div class="info-item-2">Javaweb_filter</div></div><div class="info-2"><div class="info-item-1">Session和Cookie什么是会话跟踪技术会话跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。保持对用户会话期间的数据管理。常用的会话跟踪技术是Cookie与Session。 Cookie通过在客户端记录信息确定用户身份 Session通过在服务器端记录信息确定用户身份。 Cookie1.什么是cookie12Cookie是客户端(一般指浏览器)请求服务器后,服务器发给客户端的一个辨认标识，保存在客户端，当客户端再次向服务器发送请求时，会携带着这个辨认标识，服务器就可以通过这个标识来识别客户端的身份或状态等。   Cookie的作用：跟踪会话，记录一次会话中(即Session，一次会话可能会有多次请求，当然也可以有多个Cookie来跟踪不同的信息)的信息，这样服务器就会知道用户的状态，比如有没有登录成功，付款时购物车中的东西等，就相当于贴在客户端脑门上的纸条，浏览器看不到，但服务器看得到。  2.Cookie的应用2.1...</div></div></div></a><a class="pagination-related" href="/2025/04/27/javaweb_mvc/" title="Javaweb_mvc"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-27</div><div class="info-item-2">Javaweb_mvc</div></div><div class="info-2"><div class="info-item-1">JavaWEB MVC写Java Web项目时会发现，一个中型或者大型项目 随着代码的增多，会发现：代码既可以写在src目录下，也可以写在WebContent目录下。src下可以建很多包 ，WebContent下可以建很多文件夹。 所以问题就来了：一个新的类 到底往哪个目录下的哪个文件夹里写？ 此时解决办法就是：需要一个模式去规范，到底哪个类该往哪里写。 ​                                                                          1.MVC设计模式Web MVC中的M(模型)-V(视图)-C(控制器)概念和标准MVC概念一样，我们再看一下Web MVC标准架构，如下图所示：  在Web MVC模式下，模型无法主动推数据给视图，如果用户想要视图更新，需要再发送一次请求（即请求-响应模型）。 M：(Model)  模型  :  应用程序的核心功能，管理这个模块中用的数据和值（bean,dao）； 1234567891011JavaBeans...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Mr.Nie</div><div class="author-info-description">Welcome to Mr.Nie's Blogs website</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/nyx-1037"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/nyx-1037" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:nyx1037678078@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFServlet"><span class="toc-number">1.</span> <span class="toc-text">1. 什么是Servlet</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Servlet-API"><span class="toc-number">2.</span> <span class="toc-text">2. Servlet API</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%AC%AC%E4%B8%80%E4%B8%AAServlet"><span class="toc-number">3.</span> <span class="toc-text">3. 第一个Servlet</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Servlet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">4. Servlet工作原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Servlet%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.</span> <span class="toc-text">5. Servlet的生命周期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E8%AF%B7%E6%B1%82"><span class="toc-number">6.</span> <span class="toc-text">6. 请求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%93%8D%E5%BA%94"><span class="toc-number">7.</span> <span class="toc-text">7. 响应</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E4%BC%9A%E8%AF%9D"><span class="toc-number">8.</span> <span class="toc-text">8. 会话</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E8%8E%B7%E5%BE%97%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%82%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">9.获得初始化参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-servlet3-0"><span class="toc-number">10.</span> <span class="toc-text">10.servlet3.0</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/27/Git/" title="Git">Git</a><time datetime="2025-04-26T16:00:00.000Z" title="发表于 2025-04-27 00:00:00">2025-04-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/27/javaweb_ajax/" title="Javaweb_ajax">Javaweb_ajax</a><time datetime="2025-04-26T16:00:00.000Z" title="发表于 2025-04-27 00:00:00">2025-04-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/27/javaweb_jsp/" title="Javaweb_jsp">Javaweb_jsp</a><time datetime="2025-04-26T16:00:00.000Z" title="发表于 2025-04-27 00:00:00">2025-04-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/27/javaweb_filter/" title="Javaweb_filter">Javaweb_filter</a><time datetime="2025-04-26T16:00:00.000Z" title="发表于 2025-04-27 00:00:00">2025-04-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/27/javaweb_mvc/" title="Javaweb_mvc">Javaweb_mvc</a><time datetime="2025-04-26T16:00:00.000Z" title="发表于 2025-04-27 00:00:00">2025-04-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Mr.Nie</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>